{% extends 'base.html' %}
{% load static %}


{% block styles %}
    <link rel="stylesheet" href="{% static 'css/app/general.css' %}">
{% endblock styles %}


{% block content %}
<main>

    <section class="row mx-auto max-90" style="margin-top: 9em;">
        <div class="col-lg-2 ms-auto">
            <a href="#" id="go_to_practice">Ir a la practica</a>
        </div>
    </section>
    <section class="row mx-auto max-90" style="margin-top: 1em;">
        <div class="col-lg-12">
            <div class="row mx-auto" id="section1">
                <h3 class="fw-bolder">2.1 Tipo de consistencias</h3>
                <div class="col-lg-6 py-3">
                    <p>
                        Hemos visto algunas de las importantes construcciones de bloques de expresiones. 
                        Ahora vamos a aprender que salida obtenemos cuando algo sale mal. 
                        Los operadores también tienen tipos particulares que ellos requieren para operar. 
                        Ciertos operadores toman operandos de un tipo particular para poder funcionar, por ejemplo, el operador <span class="font-bold">/</span> el cual requiere operandos de tipo 
                        <span class="font-bold">real</span>, o por ejemplo el operador <span class="font-bold">div</span> que requiere de tipo <span class="font-bold">integer</span>. 
                        Es por eso que es necesario tener claro los tipos de valores con los que se pueden operar para que no se obtenga un error. 
                        Para entender mejor veamos acerca de los tipos de errores con los que nos podremos encontrar a trabajar con SML.
                    </p>
                    <h4>Tipo de errores</h4>
                    <p>
                        Como hemos visto cuando una operación recibe operandos de los tipos adecuados da como resultado una respuesta positiva sin ningún error, 
                        sin embargo, cuando uno o ambos operandos son de tipo erróneo vamos a obtener un error. 
                        La naturaleza del error depende de la implementación en particular. 
                        Por ejemplo, el operador <span class="font-bold">+</span> puede tomar como argumento tanto un entero como un <span class="font-bold">real</span> sin embargo 
                        ambos operadores deben ser del mismo tipo. Cuando el tipo de los operandos son el mismo, 
                        entonces el resultado de la operación es del mismo tipo.
                    </p>
                    <pre class="w-50">
                        <code style="height: 60px;" class="language-vb">  1+2;
  1.0 + 2.0;
                        </code>
                    </pre>
                    <pre class="w-50 desactivate" style="margin-top: -80px;" id="codebtn1">
                        <code style="height: 60px;" class="language-vb">  val it = 3 : int
  val it = 3.0 : real
                        </code>
                    </pre>
                    <a href="#" data-btn="btn1" class="btn btn-custom-red execute-code">Ejecutar</a>

                    <p class="mt-5">
                        Por otro lado, cuando los operandos son <span class="font-red-bold">mixtos</span> se va a obtener como respuesta un mensaje de error, esto quiere que los operando son de dos tipos diferentes (como por ejemplo <span class="font-bold">integer</span> y <span class="font-bold">real</span>), veamos lo que responde ML
                    </p>

                    <pre class="w-75">
                        <code style="height: 60px;" class="language-vb">  1 + 2.0;
                        </code>
                    </pre>
                    <pre class="w-75 desactivate" style="margin-top: -80px;" id="codebtn2">
                        <code style="height: 60px;" class="language-vb">  Error: operator and operand dont agree
    operator domain: int * int
    operand: int * real 
    in expression: 
        + : overloaded ((1 : int), 2.0)
                        </code>
                    </pre>
                    <a href="#" data-btn="btn2" class="btn btn-custom-red execute-code">Ejecutar</a>
                    <p class="mt-5">
                        La primera línea de la respuesta indica que el operador espera operandos de otro tipo, 
                        la siguiente línea dice que el operador <span class="font-bold">+</span> espera un operador cuyo tipo es un par de enteros. 
                        Aunque el operador <span class="font-bold">+</span> puede aplicarse en cualquiera de los dos casos (<span class="font-bold">enteros</span> o <span class="font-bold">reales</span>), 
                        si el argumento de la izquierda de la operación es un <span class="font-bold">entero</span>, su operación debe ser con otro argumento de tipo <span class="font-bold">entero</span>, 
                        esto debido a que ML tomará el tipo del resultado del tipo de sus argumentos. 
                        La tercera línea de la respuesta muestra que el operando de la operación es un par, donde el argumento a la izquierda del operando es 
                        de tipo <span class="font-bold">entero</span> y el de la derecha es de tipo <span class="font-bold">real</span>. 
                        Al final las últimas dos líneas indican la expresión en la cual el error ocurre. 
                    </p>
                </div>
                <div class="col-lg-6 py-3">
                    <p>
                        Nótese que en el resultado de la operación se menciona el término overloaded al lado del operador <span class="font-bold">+</span>. 
                        Un operador es <span class="font-red-bold">overladed</span> cuando puede aplicar su operación sobre dos o más argumentos del mismo tipo, como por 
                        ejemplo <span class="font-bold">-</span> , <span class="font-bold">*</span>, <span class="font-bold"><</span> , entre otros. <br>
                        Otro típico error que nos podemos encontrar a la hora de programar en ML es la división entre cero. 
                        El operador <span class="font-bold">/</span> aplica solamente para argumentos de tipo <span class="font-bold">real</span>, 
                        véase un ejemplo a continuación
                    </p>
                    <pre class="w-75">
                        <code style="height: 60px;" class="language-vb">  1/2;
                        </code>
                    </pre>
                    <pre class="w-75 desactivate" style="margin-top: -80px;" id="codebtn3">
                        <code style="height: 60px;" class="language-vb">  Error: overloaded variable not defined at type
    symbol: /
    type: int
                        </code>
                    </pre>
                    <a href="#" data-btn="btn3" class="btn btn-custom-red execute-code">Ejecutar</a>
                    <p class="mt-5">
                        La primera observación es que el error hace referencia al símbolo <span class="font-bold">/</span> y la aplicación sobre el operando de tipo entero, 
                        sin embargo por que el mensaje de overloaded en la primera línea del error?... Bien!  
                        Esto es porque mL piensa que el operador <span class="font-bold">/</span> es una variable. 
                        Adicionalmente a eso hemos mencionado que dicho operador trabaja y opera solamente con <span class="font-bold">reales</span>. <br>
                        Otra ocasión en la que podemos encontrar tipo de inconsistencias ocurren cuando manejamos expresiones <span class="font-bold">if - else</span>. La siguiente reglas definen como debería ser formada la expresión:
                        <ul>
                            <li>La expresión debe ser seguida de un valor de tipo boolean</li>
                            <li>Las expresiones que vienen despues de then y del else pueden ser de cualquier tipo, pero deben ser del mismo tipo tanto después del then como después del else</li>
                        </ul>
                        A continuación se muestra qué pasa cuando los tipos de expresiones <span class="font-bold">then</span> y <span class="font-bold">else</span> siguen con argumentos de tipos que no concuerdan:
                    </p>
                    <pre class="w-75">
                        <code style="height: 60px;" class="language-vb">  if 1 < 2 then #"a" else "bc";
                        </code>
                    </pre>
                    <pre class="w-75 desactivate" style="margin-top: -80px;" id="codebtn4">
                        <code style="height: 60px;" class="language-vb">  Error: types of rules dont agree
    earlier rule(s): bool -> char
    this rule: bool -> string
    in rule:
        false => "bc"
                        </code>
                    </pre>
                    <a href="#" data-btn="btn4" class="btn btn-custom-red execute-code">Ejecutar</a>
                    <p class="mt-5">
                        Con lo que hemos visto hasta el momento es fácil comprender porqué ocurre este error, 
                        más sin embargo vamos a explicarlo. 
                        ML nos dice que ha encontrado un argumento de tipo <span class="font-bold">string</span> cuando en realidad espera un argumento de tipo carácter para que 
                        coincida con el argumento que acompaña la expresión <span class="font-bold">then</span>. 
                        más adelante veremos cómo poder tratar las expresiones con argumentos de tipos diferentes. 
                    </p>
                </div>
                <div class="col-lg-12 my-5 text-center">
                    <a href="#" class="btn btn-custom-red next-btn" data-next="1">Siguiente</a>
                </div>
            </div>
            <div class="row mx-auto desactivate" id="section2">
                <h3 class="fw-bolder">2.2 Conversión entre enteros y reales</h3>
                <div class="col-lg-6 py-3">
                    <p>
                        Algunas veces tenemos razones por las que debemos convertir un valor de un tipo a un equivalente esto con el fin 
                        de poder tratar algunos operandos en ciertas operaciones. 
                        ML provee ciertas funciones incorporadas de conversión para nosotros. 
                        Quizás el caso más claro es cuando se quiere convertir un entero a un <span class="font-bold">real</span> con el mismo valor. 
                        La función <span class="font-bold">real</span> nos permite hacer precisamente esto. 
                        Aplicado para un entero, <span class="font-bold">real</span> produce el valor como: 
                    </p>
                    <pre class="w-50">
                        <code style="height: 60px;" class="language-vb">  real(4);
                        </code>
                    </pre>
                    <pre class="w-50 desactivate" style="margin-top: -80px;" id="codebtn5">
                        <code style="height: 60px;" class="language-vb">  val it = 4.0 : real
                        </code>
                    </pre>
                    <a href="#" data-btn="btn5" class="btn btn-custom-red execute-code">Ejecutar</a>
                    <p>
                        Otro ejemplo aplicado a una operación donde se trata de aplicar la suma entre un <span class="font-bold">entero</span> y un <span class="font-bold">real</span> sería:
                    </p>
                    <pre class="w-50">
                        <code style="height: 60px;" class="language-vb"> real(1) + 2.0;
                        </code>
                    </pre>
                    <pre class="w-50 desactivate" style="margin-top: -80px;" id="codebtn6">
                        <code style="height: 60px;" class="language-vb"> val it = 3.0 : real
                        </code>
                    </pre>
                    <a href="#" data-btn="btn6" class="btn btn-custom-red execute-code">Ejecutar</a>
                </div>
                <div class="col-lg-6 py-3">
                    <p>
                        Muestra una correcta versión de esta adición, por supuesto no hay lógica declarar <span class="font-bold">real(1)</span> cuando se podría directamente utilizar el <span class="font-bold">1.0</span>, 
                        sin embargo el objetivo de la función <span class="font-bold">real</span> es poder transformar valores almacenados en una <span class="font-red-bold">variable</span>. 
                        Ahora cuando se trata de convertir de <span class="font-bold">real a entero</span>, la cosa varía un poco ya que ML proporciona 4 funciones 
                        que permiten dicha conversión, los cuales son: <span class="font-red-bold">floor</span>, <span class="font-red-bold">ceil</span>, <span class="font-red-bold">round</span>, y <span class="font-red-bold">trunc</span>.
                        Cada valor entero producido con el mismo valor real varía dependiendo de la función utilizada. 
                        Si por ejemplo convertimos el valor 4.3 con la función <span class="font-red-bold">floor</span> nos va a devolver el valor entero inferior, 
                        a diferencia de la función <span class="font-red-bold">ceil</span> que devolverá el valor entero superior, la función <span class="font-red-bold">round</span> redondea el valor decimal ya sea al valor 
                        entero superior o inferior dependiendo dependiendo de si es mayor a 4.5 o menor a 4.5 (para este caso específicamente) y 
                        la función <span class="font-red-bold">trunc</span> borra todos los dígitos decimales de la derecha. Véase un ejemplo en la siguiente tabla
                    </p>
                    <table class="table">
                        <thead class="thead-dark">
                          <tr class="text-center">
                            <th scope="col">x</th>
                            <th scope="col">floor(x)</th>
                            <th scope="col">ceil(x)</th>
                            <th scope="col">round(x)</th>
                            <th scope="col">trunc(x)</th>
                          </tr>
                        </thead>
                        <tbody>
                          <tr class="text-center">
                            <td>3.5</td>
                            <td>3</td>
                            <td>4</td>
                            <td>4</td>
                            <td>3</td>
                          </tr>
                          <tr class="text-center">
                            <td>~3.5</td>
                            <td>~4</td>
                            <td>~3</td>
                            <td>~3</td>
                            <td>~3</td>
                          </tr>
                          <tr class="text-center">
                            <td>3.4</td>
                            <td>3</td>
                            <td>4</td>
                            <td>3</td>
                            <td>3</td>
                          </tr>
                          <tr class="text-center">
                            <td>~3.6</td>
                            <td>~4</td>
                            <td>~3</td>
                            <td>~4</td>
                            <td>~3</td>
                          </tr>
                        </tbody>
                      </table>
                </div>
                <div class="col-lg-12 my-5 text-center">
                    <a href="#" class="btn btn-custom-red next-btn" data-next="2">Siguiente</a>
                </div>
            </div>
            <div class="row mx-auto desactivate" id="section3">
                <h3 class="fw-bolder">2.1.3 Operadores Artimeticos</h3>
                <div class="col-lg-6 py-3">
                    <p>
                        Los operadores aritméticos en ML son similares a los operadores en pascal o C. Existen:
                        <ul>
                            <li>Operadores de adición y sustracción <span class="font-bold">+</span> , <span class="font-bold">-</span></li>
                            <li>Operadores de alta procedencia como los operadores de multiplicación <br> <span class="font-bold">( * )</span>, división <span class="font-bold">( div )</span> o módulo <span class="font-bold">( mod )</span></li>
                            <li>Operadores de negación <span class="font-bold">~</span></span></li>
                        </ul>
                        A continuación, unas expresiones y sus respuestas en el intérprete de ML:
                    </p>
                    <pre class="w-50">
                        <code style="height: 60px;" class="language-vb"> 3.0 - 4.5 + 6.7;
                        </code>
                    </pre>
                    <pre class="w-50 desactivate" style="margin-top: -80px;" id="codebtn6">
                        <code style="height: 60px;" class="language-vb"> val it = 5.2 : real
                        </code>
                    </pre>
                    <a href="#" data-btn="btn6" class="btn btn-custom-red execute-code">Ejecutar</a>
                </div>
                <div class="col-lg-6 py-3">
                    <p>
                        Otro ejemplo sería
                    </p>
                    <pre class="w-50">
                        <code style="height: 60px;" class="language-vb"> 43 div (8 mod 3) * 5;
                        </code>
                    </pre>
                    <pre class="w-50 desactivate" style="margin-top: -80px;" id="codebtn7">
                        <code style="height: 60px;" class="language-vb"> val it = 105 : int
                        </code>
                    </pre>
                    <a href="#" data-btn="btn7" class="btn btn-custom-red execute-code">Ejecutar</a>
                    <p>
                        Los tres operadores <span class="font-bold">div</span>, <span class="font-bold">mod</span> , y <span class="font-bold">*</span> son de la misma procedencia pero los paréntesis forza a realizar la operación mod primero y usa la notación hacia la izquierda por lo que se agruparía de la forma (43 div 2) * 5 (Donde 2 fue el resultado de la operación 8 <span class="font-bold">mod</span> 3)
                    </p>
                </div>
                <div class="col-lg-12 my-5 text-center">
                    <a href="#" class="btn btn-custom-red next-btn" data-next="3">Siguiente</a>
                </div>
            </div>
            <div class="row mx-auto desactivate" id="section4">
                <h3 class="fw-bolder">2.1.4 Operadores de comparación</h3>
                <div class="col-lg-6 py-3">
                    <p>
                        En programación existen 6 operadores de comparación comunes, los cuales son <span class="font-bold">=</span> , <span class="font-bold"><</span> , <span class="font-bold">></span> , <span class="font-bold"><=,</span> <span class="font-bold">=></span>  y <span class="font-bold"><></span>, el cual este ultimo representa la expresión “diferente de”. Podemos usar estos operadores para comparar enteros, reales, caracteres, o strings con una excepción:
                        <ul>
                            <li>
                                Los reales podrían no ser comparados usando <span class="font-bold">=</span> o <span class="font-bold"><></span>. Las otras 4 comparaciones son permitidas 
                            </li>
                        </ul>
                        Veamos algunos ejemplos de comparaciones
                    </p>
                    <pre class="w-50">
                        <code style="height: 60px;" class="language-vb"> #"Z" < #"a";
                        </code>
                    </pre>
                    <pre class="w-50 desactivate" style="margin-top: -80px;" id="codebtn8">
                        <code style="height: 60px;" class="language-vb"> val it = true : bool
                        </code>
                    </pre>
                    <a href="#" data-btn="btn8" class="btn btn-custom-red execute-code">Ejecutar</a>
                    <p class="mt-4">
                        Como se puede notar, el resultado de la comparación es un booleano. Esto es porque se esta trabajando con caracteres, por ende, en la jerarquía del código ASCII la Z mayúscula es mayor a la a minúscula.
                    </p>
                </div>
                <div class="col-lg-6 py-3">
                    <p>
                        Otro ejemplo sería
                    </p>
                    <pre class="w-50">
                        <code style="height: 60px;" class="language-vb"> 2 < 1 + 3;
                        </code>
                    </pre>
                    <pre class="w-50 desactivate" style="margin-top: -80px;" id="codebtn9">
                        <code style="height: 60px;" class="language-vb"> val it = true : bool
                        </code>
                    </pre>
                    <a href="#" data-btn="btn9" class="btn btn-custom-red execute-code">Ejecutar</a>
                    <p class="mt-4">
                        Aunque el resultado es un booleano, ahora hemos operado con números reales, en la cual decimos que 2 es menor a 1 más 3 que sería igual a 4. Cosa que efectivamente es cierta
                    </p>
                </div>
                <div class="col-lg-12 my-5 text-center">
                    <a href="#" class="btn btn-custom-red next-btn" data-next="4">Siguiente</a>
                </div>
            </div>
            <div class="row mx-auto desactivate" id="section5">
                <h3 class="fw-bolder">2.1.5 Combinación lógica de valores</h3>
                <div class="col-lg-6 py-3">
                    <p>
                        Los operadores comunes de lógica dan como resultado valores booleanos, los conectores son operadores como <span class="font-bold">AND</span>, <span class="font-bold">OR</span> y <span class="font-bold">NOT</span> como los de pascal o <span class="font-bold">&&,</span> <span class="font-bold">||</span> , y <span class="font-bold">!</span> como en C. En ML se manejan valores lógicos de combinatoria llamados <span class="font-red-bold">andalso</span> y <span class="font-red-bold">orelse</span>. 
                        Como su nombre en inglés indica, esta combinación de operadores determina la manera en como procede una instrucción en ML. A continuación, se explican dichas instrucciones.
                    </p>
                    <pre class="w-50">
                        <code style="height: 60px;" class="language-vb"> 1 < 2 orelse 3 > 4;
                        </code>
                    </pre>
                    <pre class="w-50 desactivate" style="margin-top: -80px;" id="codebtn10">
                        <code style="height: 60px;" class="language-vb"> val it = true : bool
                        </code>
                    </pre>
                    <a href="#" data-btn="btn10" class="btn btn-custom-red execute-code">Ejecutar</a>
                    <p class="mt-4">
                        ML no evalúa la segunda condición en este ejemplo debido a que la primera condición <span class="color-bold">(3 > 4)</span> da como resultado un valor booleano <span class="font-bold">true</span>, dado el caso la primera expresión hubiese dado como resultado un valor <span class="font-bold">false</span>, entraría entonces a la segunda expresión después del <span class="font-red-bold">orelse</span>.
                    </p>
                </div>
                <div class="col-lg-6 py-3">
                    <p>
                        Véase también la expresión <span class="font-red-bold">andalso</span>.
                    </p>
                    <pre class="w-50">
                        <code style="height: 60px;" class="language-vb"> 1 < 2 andalso 3 > 4;
                        </code>
                    </pre>
                    <pre class="w-50 desactivate" style="margin-top: -80px;" id="codebtn11">
                        <code style="height: 60px;" class="language-vb"> val it = false : bool
                        </code>
                    </pre>
                    <a href="#" data-btn="btn11" class="btn btn-custom-red execute-code">Ejecutar</a>
                    <p class="mt-4">
                        En este ejemplo es necesario evaluar ambas condiciones para dar el resultado, es decir, el resultado es false debido a que la segunda condición <span class="font-bold">(3 > 4)</span> es falsa a pesar de que la primera sea verdadera <span class="font-bold">(1 < 2)</span>, por ende, el resultado que arroja ML es un <span class="font-red-bold">false</span>
                    </p>
                </div>
                <div class="col-lg-12 my-5 text-center">
                    <a href="#" class="btn btn-custom-red next-btn" data-next="4">Siguiente</a>
                </div>
            </div>
            <div class="row mx-auto desactivate" id="section6">
                <h3 class="fw-bolder">2.1.6 Expresión If-Then-Else</h3>
                <div class="col-lg-12 py-3">
                    <p>
                        ML nos permite utilizar expresiones condicionales de la forma <span class="font-bold">if</span> E <span class="font-bold">then</span> F <span class="font-bold">else</span> G. Esta expresión lo que garantiza es que se valide si la expresión <span class="font-red-bold">E</span> es verdadera, entonces se ejecutara <span class="font-red-bold">F</span> de lo contrario se ejecutara <span class="font-red-bold">G</span>. Considere la siguiente expresión condicional
                    </p>
                    <pre class="w-50">
                        <code style="height: 60px;" class="language-vb"> if 1 < 2 then 3 + 4 else 5 + 6;
                        </code>
                    </pre>
                    <pre class="w-50 desactivate" style="margin-top: -80px;" id="codebtn12">
                        <code style="height: 60px;" class="language-vb"> val it = 7 : int
                        </code>
                    </pre>
                    <a href="#" data-btn="btn12" class="btn btn-custom-red execute-code">Ejecutar</a>
                    <p class="mt-4">
                        El resultado es 7 debido a que la expresión tiene como primera condición <span class="font-bold">(1 < 2)</span>, el cual dicha condición da como resultado un <span class="font-bold">true</span>, este porque efectivamente 1 es menor que 2, como la condición es <span class="font-bold">true</span> entonces entrara al <span class="font-bold">then</span> el cual ejecuta la suma entre 3 y 4 que da como resultado el número 7.
                    </p>
                </div>
                <div class="col-lg-12 my-5 text-center">
                    <a href="#" class="btn btn-custom-red next-btn" data-next="4">Siguiente</a>
                </div>
            </div>
            <section class="row mx-auto max-90 desactivate" id="section7">
                <div class="col-lg-12 col-12" style="margin-top: 2em;text-align: center;">
                    <div class="card" style="width: 18rem; display: inline-block;">
                        <div class="card-body">
                            <h5 class="card-title">Ejemplos</h5>
                            <p class="card-text text-start" style="height: 180px">
                                A continuación, se presentarán una serie de ejemplos los cuales contendrán sus enunciados y un paso a paso el cual permitirá al estudiante tener una comprensión más detallada de los temas tratados en este módulo
                            </p>
                            <a href="{% url 'expressions:ejemplo1' %}" class="card-link">Vamos a practicar</a>
                        </div>
                    </div>
    
                    <div class="card" style="width: 18rem; display: inline-block;">
                        <div class="card-body">
                          <h5 class="card-title">Ejercicios</h5>
                          <p class="card-text text-start" style="height: 180px;">Los ejercicios buscan poder mejorar lo aprendido en este módulo, se le recomienda al estudiante realizar esta sección de ejercicios para poder culminar satisfactoriamente el módulo.</p>
                          <a href="{% url 'tipos_variables:ejercicios' %}" class="card-link">Vamos a practicar</a>
                        </div>
                      </div>
    
                </div>
                <div class="col-lg-12 col-12 text-center" style="margin: 3em 0em;">
                    <a href="#" class="btn btn-danger next">
                        Ir al módulo 2
                    </a>
                </div>
            </section>
        </div>
    </section>
</main>
{% endblock content %}

{% block scripts %}
<script>
    // alertify.alert(
    //     'Para tener en cuenta!', 'Antes de empezar a mencionar sobre ML, es recomendable leer el manual de usuario para poder instalar ML en su computador y de esa manera poder llevar a cabo los ejemplos y ejercicios que se desarrollen en los módulos', 
    //     function(){ }
    // );
    let section = 1;
    $(document).ready(function(){
        $(".execute-code").each(function(){
            $(this).on('click',function(e){
                e.preventDefault()
                btncode = "#code"+$(this).attr('data-btn')
                $(btncode).toggle("explode")
                $(this).toggle("explode")
            })
        })
        $(".next-btn").each(function(){
            $(this).on('click',function(e){
                e.preventDefault()
                btn_current_section = parseInt($(this).attr('data-next'))
                next_section = "#section"+(btn_current_section + 1);
                current_section = "#section"+btn_current_section;
                console.log(next_section);
                console.log(current_section);
                $(current_section).addClass("desactivate")
                $(next_section).removeClass("desactivate")
            })
        })
        $('#go_to_practice').on('click', function(e){
            for(var i = 1; i < 7; i ++){
                target_tag = "#section"+i
                if(!$(target_tag).hasClass('desactivate')){
                    $(target_tag).addClass('desactivate')
                }
            }
            $('#section7').removeClass('desactivate')
            $('#go_to_practice').toggle('explode')
        })
    })
</script>
{% endblock scripts %}